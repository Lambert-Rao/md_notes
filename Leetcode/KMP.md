# KMP

> KMP的核心思想：利用之前匹配过的文本信息，避免重复匹配

模式串：要匹配的`subStr`

文本串/主串：被匹配的`String`

## 前缀表`Prefix Table`

前缀表其实就是最长相同前后缀的表

举个例子:

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | F    |
| 0    | 1    | 0    | 1    | 2    | 0    |

每个字母`i`所对应的`prefix`值代表了`String[0..i]`闭区间内最长相同前后缀的值(这里当然要去掉和自己相等的串，这是没意义的)。这个数值表示了匹配失败时当前已匹配的串最大的利用空间。

### `next`数组

`next`是计算`KMP`过程中需要使用到的一个辅助量，简单起见可以直接使用`prefixTable`作为`next`数组。

#### 如何计算`next`？

1. 定义两个指针i和j, 初始化时`j = 0; i = 1;`
2. 构建一个循环`for (int i = 1; i < s.length(); i++)`, 可以看到这是一个模式串长度的循环，因为我们本来就是要对模式串的每一个字符求取对应的数值。每次循环结束后`next[i] = j;`
3. 对于当前i指定的字符，有两种情况要讨论：
- 如果i和j对应的字符相同，`j++;`, 然后赋值next.

| 0 j  | 1 i  | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | F    |
| 0    |      |      |      |      |      |



| 0    | 1 i j | 2    | 3    | 4    | 5    |
| ---- | ----- | ---- | ---- | ---- | ---- |
| A    | A     | B    | A    | A    | F    |
| 0    | 1     |      |      |      |      |

可以看到next[1]已经被赋值1，这是通过是通过计算`原来位置的j(0)`和i`位置(1)`的字符来得到的，这两个字符的相等说明了一个`原有长度(0)+1`长度 的字符串构成了相同前后缀。

- 如果i和j对应的字符不相同：

我们接着计算，这时惊人地发现`next[i] != next[j]`, 这说明我们之前计算的相同前后缀已经无法再维持下去了，那只能退而求其次，看看减少一点长度，能不能构成相同前后缀。

```java
while (j > 0 && s.charAt(j) != s.charAt(i)) {
                    j = next[j - 1];
                }
```

| 0    | 1    | 2    | 3    | 4 j  | 5 i  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | F    |
| 0    | 1    | 0    | 1    | 2    |      |

我们把`j`重置了，重置到`next[4-1]`, 关键的问题来了，这里的`next[4-1]`代表了什么呢？

当`j=4`时，`next[4] != next5]`, 这正是我提到的，相同前后缀不能维持了(之前维持在2，也就是`AABAA`的`AA`)，这里，我要利用一个已知信息，就是前后缀`AA`，因为这二者的相等，我把问题转换为了判断`AAB`和`AAF`是否相等，而这个判断也只需要判断最后一个字母`B`和`F`是否相等，但是很可惜还是不相等，最后回退到0的位置。
| 0    | 1    | 2 j  | 3    | 4    | 5 i  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | F    |
| 0    | 1    | 0    | 1    | 2    |      |



| 0 j  | 1    | 2    | 3    | 4    | 5 i  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | F    |
| 0    | 1    | 0    | 1    | 2    |      |

## 利用`next`计算子串位置

请看我们有这样一个问题：

主串：`A A B A A B A A F A A`

子串：`A A B A A F`



| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | B    | A    | A    | F    | A    |

还是定义i和j，这和求取next是类似的。

- 同样的一个循环，让i 从 0 到 `mainStr.lenth`.
  - 在循环中，可能出现3种情况。

1. `subStr[j] == mainStr[i]`, 这说明两个字符串有所对应了，让`j++`. 

| 0 i j | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A     | A    | B    | A    | A    | B    | A    | A    | F    | A    |
| A     | A    | B    | A    | A    | F    |      |      |      |      |
| 0     | 1    | 0    | 1    | 2    | 0    |      |      |      |      |

2. `subStr[j] != mainStr[i]` 首先注意，如果能到达这一步，说明前面已经有一部分的字符串能够匹配了，也就是[0,4] `A A B A A`, 接下来是要比较第6个字符能否同样幸运地相等。但是很可惜，不相等。这里按照常规做法，那就是要从第二个字符开始对齐比较了，但是我们当然不会这样做，这里要利用`A A B A A`的最大相同前后缀长度2，把j重置到2, 再进行比较，比较成功，j留在2的位置。我们利用了长度2代表的`AA`和`AA`相等，再进行了比较得到`AAB`和`AAB`的相等，然后就可以推进我们的循环了。

| 0    | 1    | 2    | 3    | 4    | 5 i j | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | B     | A    | A    | F    | A    |
| A    | A    | B    | A    | A    | F     |      |      |      |      |
| 0    | 1    | 0    | 1    | 2    | 0     |      |      |      |      |

| 0    | 1    | 2 j  | 3    | 4    | 5 i  | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | B    | A    | A    | F    | A    |
| A    | A    | B    | A    | A    | F    |      |      |      |      |
| 0    | 1    | 0    | 1    | 2    | 0    |      |      |      |      |
3. `j == next.length`, 一整个子串已经被比较完了，我们返回这个结果就行了。

```java
return i - j + 1;
```

| 0    | 1    | 2    | 3    | 4    | 5    | 6 j  | 7    | 8 i  | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | A    | B    | A    | A    | B    | A    | A    | F    | A    |
| A    | A    | B    | A    | A    | F    |      |      |      |      |
| 0    | 1    | 0    | 1    | 2    | 0    |      |      |      |      |

## 代码

```java
class Solution {

        public int strStr(String mainStr, String subStr) {
            int[] next = getNext(subStr);
            if (subStr.length()==0){
                return 0;
            }
            int j = 0;
            for (int i = 0; i < mainStr.length(); i++) {
                while (j > 0 && subStr.charAt(j) != mainStr.charAt(i)) {
                    j = next[j - 1];
                }
                if (subStr.charAt(j) == mainStr.charAt(i)) {
                    j++;
                }
                if (j == next.length) {
                    return i - j + 1;
                }
            }
            return -1;
        }

        // a a b a a f
        // 0 1 0 1 2 0
        private int[] getNext(String s) {
            int[] next = new int[s.length()];
            int j = 0;
            next[0] = 0;
            for (int i = 1; i < s.length(); i++) {
                while (j > 0 && s.charAt(j) != s.charAt(i)) {
                    j = next[j - 1];
                }
                if (s.charAt(j) == s.charAt(i)) {
                    j++;
                }
                next[i] = j;
            }
            return next;
        }
    }
```

